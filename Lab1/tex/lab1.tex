\documentclass[a4paper,12pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{geometry}
\geometry{top=2cm, bottom=2cm, left=2cm, right=2cm}

% Добавляем красную строку и после section
\usepackage{indentfirst}
\setlength{\parindent}{0.75cm}

\begin{document}

\begin{center}
    \Large\textbf{Лабораторная работа №1}\\[5pt]
    \large Вариант 14
\end{center}

\[
\begin{cases}
ac \rightarrow c \\
aa \rightarrow ba \\
bc \rightarrow c \\
ca \rightarrow aa \\
cb \rightarrow bc \\
ccc \rightarrow c \\
aaa \rightarrow aa \\
aab \rightarrow ba \\
abb \rightarrow aba \\
bbb \rightarrow bba
\end{cases}
\]

\section*{Первичный анализ}

Слова в данной SRS образованы из алфавита $\{a, b, c\}$. Кроме того, все правила этой системы не увеличивают длину строки. 
Поэтому можно переписать систему так, чтобы сначала шли правила, уменьшающие длину слова, а затем правила, сохраняющие её. 
Получаем:

\[
\begin{cases}
ac \rightarrow c & (1) \\
bc \rightarrow c & (2) \\
ccc \rightarrow c & (3) \\
aaa \rightarrow aa & (4) \\
aab \rightarrow ba & (5) \\
aa \rightarrow ba & (6) \\
ca \rightarrow aa & (7) \\
cb \rightarrow bc & (8) \\
abb \rightarrow aba & (9) \\
bbb \rightarrow bba & (10)
\end{cases}
\]

Пронумеруем каждое преобразование для удобства. Также можно отметить, что все преобразования, кроме (6), 
образуют фундированную последовательность при сравнении слов сначала по длине, а затем лексикографически (ShortLex). 
Это может быть полезно в дальнейшем.

\section*{Завершимость}

Данная система переписывания не является завершимой. Можно найти цикл:
\[
bbaaa \xrightarrow{(6)} bbbaa \xrightarrow{(10)} bbaaa
\]

\section*{Конечность классов эквивалентности по НФ}

Система имеет бесконечное число классов эквивалентности по нормальной форме. 
Рассмотрим слова вида $(ab)^n$, где $n \in \mathbb{N}$. Ни одно из этих слов не поддаётся преобразованию с помощью данной системы, 
а таких слов бесконечно много. Следовательно, нормальных форм бесконечно много.

\section*{Локальная конфлюэнтность}

Рассмотрим слово $abbbc$. Применив к нему отдельно правила (9) и (10), получаем слова $ababc$ и $abbac$. 
К слову $ababc$ можно применить только правило (2), которое даёт слово $abac$ длины 4. 
Следовательно, для слова $abbac$ нужно применить правило, уменьшающее его длину на 1. 
Для этого подходит только правило (1), которое даёт слово $abbc$. 
Так как $abac \neq abbc$, SRS не локально конфлюэнтна.

\section*{Пополняемость по Кнуту–Бендиксу}

Для того чтобы начать применять алгоритм пополнения Кнута–Бендикса, нужно, чтобы система имела термориентированный порядок. 
Но если бы он был, то система переписывания была бы завершаемой, чего быть не может, так как у системы есть цикл. 
Поэтому данная SRS не пополняема по Кнуту–Бендиксу. 
Однако, если изменить правило (6) на $ba \rightarrow aa$, то будет выполняться ShortLex.

\section*{Пополнение}

Для проверки пополняемости системы рассмотрим все критические пары, возникающие при наложении левых частей правил. Всего таких пар 34:
\[
\text{ccc--ccc(x2)}, \; \text{aaa--aaa(x2)}, \; \text{bbb--bbb(x2)}, \; \text{ac--ccc}, \; \text{ac--aaa}, \; \text{ac--ba}, \; \text{ac--ca(x2)}, \; \text{ac--cb}, 
\]
\[
\text{bc--ccc}, \; \text{bc--aab}, \; \text{bc--ca}, \; \text{bc--cb}, \; \text{bc--abb}, \; \text{bc--bbb}, \; \text{ccc--ca}, \; \text{ccc--cb}, \; \text{aaa--aab(x2)}, 
\]
\[
\text{aaa--ba}, \; \text{aaa--ca}, \; \text{aaa--abb}, \; \text{aab--ba}, \; \text{aab--ca}, \; \text{aab--bbb}, \; \text{bba--cb}, \; \text{ba--abb(x2)}, \; \text{ba--bbb}, 
\]
\[
\text{ca--abb}, \; \text{cb--bbb}.
\]

Пары \( ca-ac \) и \( cb-bbb \) порождают слова \( cac \) и \( cbbb \) нарушающие конфлюэнтность системы, поскольку каждое из них может быть редуцировано более чем одним способом, приводящим к различным нормальным формам: \( cac \) может переходить в \( c \) или \( cc \), а \( cbbb \) в \( c \) или \( aa \).

Для устранения проблемы добавим правило \( cc \rightarrow c \).  
Его введение создаёт новые критические пары:
\[
cc\text{--}cc, \; ac\text{--}cc, \; bc\text{--}cc, \; ccc\text{--}cc, \; cc\text{--}ca, \; cc\text{--}cb,
\]
все из которых сводятся к нормальной форме \( c \) или \( aa \).

После этого добавляем правило \( aa \rightarrow c \), чтобы устранить оставшиеся неоднозначности.  
При этом появляются новые пары:
\[
aa\text{--}aa, \; aa\text{--}ac, \; aa\text{--}aaa, \; aa\text{--}aab, \; ba\text{--}aa, \; ca\text{--}aa, \; aa\text{--}abb,
\]
которые также сводятся к нормальной форме \( c \).

В результате получаем пополненную систему переписываний, которая является завершаемой и конфлюэнтной:
\[
\begin{cases}
\mathbf{cc \rightarrow c} & (1)\\
\mathbf{aa \rightarrow c} & (2)\\
ac \rightarrow c & (3)\\
bc \rightarrow c & (4)\\
ccc \rightarrow c & (5)\\
aaa \rightarrow aa & (6)\\
aab \rightarrow ba & (7)\\
ba \rightarrow aa & (8)\\
ca \rightarrow aa & (9)\\
cb \rightarrow bc & (10)\\
abb \rightarrow aba & (11)\\
bbb \rightarrow bba & (12)
\end{cases}
\]


\section*{Нормальные формы}

Так как все слова длины 3 редуцируются, то к любым словам большей длины тоже применима полученная система. Следовательно, множество нормальных форм конечно.

У полученной системы количество нормальных форм сократилось по сравнению с исходной:\\[4pt]
-- в первой системе нормальные формы: $\{\varepsilon, a, b, c, aa, ab, bb, cc\}$;\\
-- во второй системе: $\{\varepsilon, a, b, c, ab, bb\}$.


\section*{Минимизация}

Цель минимизации системы переписывания заключается в том, чтобы уменьшить длину слов и количество правил в системе, не изменяя при этом множество достижимых нормальных форм. 

Правило (5) можно удалить, так как его действие полностью воспроизводится с помощью двух последовательных применений правила (1).

Правило (6) также является избыточным, поскольку результат его применения можно получить при помощи уже существующих правил: aaa \xrightarrow{(2)} ca \xrightarrow{(9)} aa.

Если для нас важно сохранить все промежуточные слова, возникающие в процессе применения правил переписывания, то на этом этапе минимизацию можно считать завершённой, поскольку каждое оставшееся правило выполняет уникальную функцию и не может быть выражено через остальные.

Однако, если целью является лишь получение конечного результата, то есть нормальной формы слова, то систему можно упростить ещё больше.

Поскольку все слова длины~2, за исключением \(ab\) и \(bb\), являющихся нормальными формами, редуцируются к~\(c\), а также все слова длины~3 в~итоге тоже переходят в~\(c\), при этом длина слова на каждом шаге не уменьшается более чем на~единицу, систему переписывания можно минимизировать сильнее:



\[
\begin{cases} 
cc \rightarrow c \\
aa \rightarrow c \\
ac \rightarrow c \\
bc \rightarrow c \\
ba \rightarrow c \\
ca \rightarrow c \\
cb \rightarrow c \\
abb \rightarrow c \\
bbb \rightarrow c
\end{cases}
\]

В~такой системе все слова, не являющиеся изначально нормальными формами, непосредственно переходят в~\(c\), что полностью соответствует свойству итогого результата алгоритма Кнута–Бендикса.


\section*{Инварианты}

\begin{enumerate}
    \item Количество символов $b$ не возрастает.
    \item Длина строки не увеличивается.
    \item Слово всегда убывает по правилу ShortLex.
    \item Суммарное расстояние символов $b$ до начала строки не увеличивается.
    \item Слово либо уже является нормальной формой, либо после применения любого правила переписывания в нём всегда остаётся хотя бы один символ $a$ или $c$.
    \item Если в слове отсутствует символ $b$, то в процессе преобразований символ $b$ никогда не появится.
    \item Пусть дана функция 
    \[
    f(w) = |w|_a + |w|_b + 2 \cdot |w|_c,
    \]
    где $|w|_x$ обозначает количество символов $x$ в слове $w$. Тогда при любом применении правила значение функции $f(w)$ не увеличивается.
    \item[$7'$.] Пусть дана функция 
    \[
    f(w) = 2^{\,|w|_a + |w|_b} * 3^{\,|w|_c}.
    \]
    Значение этой функции также не увеличивается при применении любого правила переписывания.
    \item Сопоставим каждому символу матрицу:
    \[
    a = 
    \begin{pmatrix}
    1 & 1 \\
    1 & 1
    \end{pmatrix}, \quad
    b =
    \begin{pmatrix}
    1 & 2 \\
    2 & 1
    \end{pmatrix}, \quad
    c =
    \begin{pmatrix}
    2 & 1 \\
    1 & 2
    \end{pmatrix}.
    \]
    Обозначим матрицу, соответствующую левой части правила, через $L$, а матрицу, соответствующую правой части через $R$. Для каждого преобразования выполняется поэлементное неравенство $L \geq R$. Следовательно, при замене подстроки, соответствующей матрице $L$, на подстроку, соответствующую матрице $L - R$, получаем выражение, являющееся матрицей без отрицательных элементов, поскольку все элементы матрицы $L - R$ неотрицательны. 
    
    Таким образом, применение такого преобразования не может привести к появлению отрицательных элементов в произведении всех матриц строки после преобразования.

    Для следующего преобразования все символы становятся какими и были до этого.

\end{enumerate}

\section*{Итог}
\[
\boldsymbol{SRS \tau} :
\begin{cases}
ac \rightarrow c \\
bc \rightarrow c \\
ccc \rightarrow c \\
aaa \rightarrow aa \\
aab \rightarrow ba \\
aa \rightarrow ba \\
ca \rightarrow aa \\
cb \rightarrow bc \\
abb \rightarrow aba \\
bbb \rightarrow bba
\end{cases}
\]

\[
\boldsymbol{SRS \tau}' :
\begin{cases}
cc \rightarrow c \\
aa \rightarrow c \\
ac \rightarrow c \\
bc \rightarrow c \\
aab \rightarrow ba \\
ba \rightarrow aa \\
ca \rightarrow aa \\
cb \rightarrow bc \\
abb \rightarrow aba \\
bbb \rightarrow bba
\end{cases}
\]




\end{document}

